"""
Задача: Проверка более общего свойства дерева поиска
Данная задача полностью аналогична предыдущей, но проверять теперь нужно более общее
свойство. Дереву разрешается содержать равные ключи, но они всегда должны находиться в
правом поддереве. Формально, двоичное дерево называется деревом поиска, если для любой
вершины её ключ больше всех ключей из её левого поддерева и не меньше всех ключей
из правого поддерева.

Ограничения.
0 ≤ n ≤ 10^5; −2^31 ≤ keyi ≤ 2^31−1 (таким образом, в качестве ключей допустимы
минимальное и максимальное значение 32-битного целого типа, будьте осторожны с
переполнением);
−1 ≤ lefti, righti ≤ n − 1.
Гарантируется, что вход задаёт корректное двоичное дерево:
в частности, если lefti != −1 и righti != −1, то lefti != righti;
никакая вершина не является сыном двух вершин;
каждая вершина является потомком корня.

Sample Input:
3
2 1 2
1 -1 -1
3 -1 -1
Sample Output:
CORRECT
"""

def in_order(i, tree, res):
    """
    произвести рекурсивный вызов для v.left,
    напечатать v.key,
    произвести рекурсивный вызов для v.right.
    """
    key, left, right = tree[i]

    if left != -1:
        if key != tree[left][0]:
            in_order(left, tree, res)

    res.append(key)

    if right != -1:
        in_order(right, tree, res)

    return res

import sys

n = int(input())
tree, res = [], []

if n == 0:
    print("CORRECT")
else:
    if n > 900:
        sys.setrecursionlimit(n + 1)

    for i in range(n):
        tree += [list(map(int, input().split()))]

    decision = in_order(0, tree, res) == sorted(res) and len(res) == len(tree)
    print(["INCORRECT", "CORRECT"][decision])